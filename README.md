# gc-server-shell-proxy

### Приложение-прокси для запуска процесса выполнения команд на сервере через API

Для конфигурации команд небходимо в папке command создать файл *command.yaml*

пример содержимого command.yaml находиться в файле command.yaml.dist.

Этот файл нужен для регистрации команд в приложении и конфигурации достура к ним.
Итак, по порядку:

`test_command` - уникальное имя команды (их можно зарегистрировать любое количество, но имя каждой должно быть уникальным)

`executable: 'test.sh'` - эта строка указывает на то, какой скрипт надо исполнить при запросе запуска этой команды через API

`return_stdout: true` - определяет, нужно ли возвращать результат работы команды

`arguments_reflection: '{arg1} {arg2} {arg3}'` - это порядок и формат вывода аргументов. в фигурных скобках значния аргументов передаваемых команде по API, все, что за их пределами останется неизенным. 
Это значит, что можно настраивать не только порядок но и формат, как например: `arguments_reflection: '{x} -y {y} --z-value {z}'`

`arguments` - эта секция отвечает за валидацию параметров. У каждого элемента в этом списке есть значения `required` и `type`. Это позволяет проверить, все ли `required` аргументы были переданы, а так же провалидировать, что к примеру на месте аргумента с типом `integer` не передается строка

## Как оно работает: 
1) клиент делает запрос на сервер в формате `/command.php?command=test_command?arg1=A&arg2=b&arg3=c`
2) сервер ищет конфигурацию команды по значению параметра `command` в `command.yaml`. То бишт в данном случае он бдует искать команду с именем `test_command`
3) Если команда найдена, проверяет, задано ли для нее в `commands.yaml` значение `executable:` - это единственное обязательное значение (очевидно, ведь без него и запускать нечего)
4) Если значение найдено, то проверяет, переданы ли в url запроса от клиента все обязательные аргументы, а так же соответствуют ли типы переданных начений тем, что указаны в `commands.yaml`
5) Если все проверки пройдены, то он переходит к генерации самой команды: берет значение `arguments_reflection` и подствляет в него значения из запроса - так он получает все аргументы команды в нужном виде, потом он генерирует команду вида `<Путь_до_папки_сервера>/executable/<значение_executable_из_yaml_конфига>`. Ну и последняя часть этого этапа - склейка пути к скрипт и всех аргументов. по итогу - готовая команда.
6) Ну и наконец - выполняет полученную команду. И если в конфигурации команды значение `return_stdout` было выставлено в `true` - вернет результат выполения команды в ответе. Если нет - вернет `null`

## Итого
Чтобы заставить скрипт работать достаточно положить любой исполняемый файл (важно не забыть выдать `+x` права) в папку `executable` и написать простую конфигурацию в `command.yaml`

Для проверки работоспособности я добавил один тестовый скрипт который просто делает `echo $@;`.
чтобы он заработал, просто перенеси содержимое `command.yaml.dist` в `command.yaml`
после этого, при отправке запроса вида: `/command.php?command=test&arg1=string_example&arg2=true&arg3=10` приложение вернет ответ `{"success":true,"data":"0 1 10\n"}`

#Установка

Код совместим с PHP >=7.1

Перед запуском обязательно выполнить `composer install` в корневой директории проекта